<!DOCTYPE html>
<html>
<head>
    <style>
        body { 
            display: flex;
            justify-content: center; 
            flex-direction: column;
        }
        canvas {
            width: 800px;
            height: 600px;
        }
        #the-canvas { border: 1px solid darkblue; }
    </style>
</head>

<body>
    <div id="imageIDs"></div>
    <link rel="stylesheet" type="text/css" href="./keyboardKeyDisplay/imageDisplay.css">
    <script src="keyboardKeyDisplay/key_printer.js"></script>
    <canvas id="the-canvas" width="800" height="600"></canvas>
    <script src="lib.js"></script>
    <script src="vector.js"></script>
    <script src="matrix.js"></script>
    <script src="uv_mesh.js"></script>
    <script src="controls.js"></script>
    <script src="cam.js"></script>
    <script src="material.js"></script>
    <script src="shader.js"></script>

    <script>
        let canvas = document.getElementById('the-canvas');
        let gl = canvas.getContext('webgl2');
        set_render_params(gl);

        // Compile shaders and create program
        let shader_program = create_compile_and_link_program(gl, vertexShaderSource, fragmentShaderSource);
        gl.useProgram(shader_program);

        // Load the material (texture)
        let metal = new Material(gl, '/metal_scale.png', gl.NEAREST);

        // Phong Lighting Parameters
        gl.uniform1f(gl.getUniformLocation(shader_program, "ambientStrength"), 0.25);
        gl.uniform1f(gl.getUniformLocation(shader_program, "diffuseStrength"), 1.0);
        gl.uniform1f(gl.getUniformLocation(shader_program, "specularStrength"), 2.0);
        gl.uniform1f(gl.getUniformLocation(shader_program, "shininess"), 4.0);

        // Point Light Properties (Red Light on Bottom-Left)
        let pointLightPos = [-0.8, -0.5, 0.5]; // Adjusted position to be closer to the bottom-left area
        let pointLightColor = [1.0, 0.0, 0.0]; // Red
        gl.uniform3fv(gl.getUniformLocation(shader_program, "pointLightPos"), pointLightPos);
        gl.uniform3fv(gl.getUniformLocation(shader_program, "pointLightColor"), pointLightColor);

        // Directional Light Properties (White Light from Top-Right)
        let dirLightDirection = [1.0, -1.0, -1.0];
        let dirLightColor = [1.0, 1.0, 1.0]; // White
        gl.uniform3fv(gl.getUniformLocation(shader_program, "dirLightDirection"), dirLightDirection);
        gl.uniform3fv(gl.getUniformLocation(shader_program, "dirLightColor"), dirLightColor);

        // View Position (Camera Position)
        let viewPos = [0.0, 0.0, -2.2];
        gl.uniform3fv(gl.getUniformLocation(shader_program, "viewPos"), viewPos);

        // Set up projection matrix
        let projection = Mat4.perspective_fovx(0.25, 4 / 3, 0.125, 128);

        // Create a UV sphere with 16 subdivisions
        let sphere = UvMesh.uvSphere(gl, shader_program, 1, 16, metal);

        // Set up camera and controls
        let keys = Keys.start_listening();
        let cam = new Camera();
        cam.translate(0, 0, -2.2);

        // Key mappings for camera control
        const DESIRED_TICK_RATE = 60;
        const DESIRED_MSPT = 1000.0 / DESIRED_TICK_RATE;
        const ROTATION_SPEED = 0.125; // eighth turn per second
        const ROTATION_SPEED_PER_FRAME = ROTATION_SPEED / DESIRED_TICK_RATE;
        const FLY_SPEED = 1;    // units per second
        const FLY_SPEED_PER_FRAME = FLY_SPEED / DESIRED_TICK_RATE;

        const KEYMAP = {
            'KeyW': function() { cam.move_in_direction(0, 0, FLY_SPEED_PER_FRAME); },
            'KeyS': function() { cam.move_in_direction(0, 0, -FLY_SPEED_PER_FRAME); },
            'KeyA': function() { cam.move_in_direction(-FLY_SPEED_PER_FRAME, 0, 0); },
            'KeyD': function() { cam.move_in_direction(FLY_SPEED_PER_FRAME, 0, 0); },
            'Space': function() { cam.translate(0, FLY_SPEED_PER_FRAME, 0); },
            'KeyC': function() { cam.translate(0, -FLY_SPEED_PER_FRAME, 0); },
            'KeyQ': function() { cam.add_roll(-ROTATION_SPEED_PER_FRAME); },
            'KeyE': function() { cam.add_roll(ROTATION_SPEED_PER_FRAME); },
            'ArrowLeft': function() { cam.add_yaw(-ROTATION_SPEED_PER_FRAME); },
            'ArrowRight': function() { cam.add_yaw(ROTATION_SPEED_PER_FRAME); },
            'ArrowUp': function() { cam.add_pitch(-ROTATION_SPEED_PER_FRAME); },
            'ArrowDown': function() { cam.add_pitch(ROTATION_SPEED_PER_FRAME); },
        };

        // Update function for camera movement
        function update() {
            let keys_down = keys.keys_down_list();

            for (const key of keys_down) {
                let bound_function = KEYMAP[key];
                if (bound_function) {
                    bound_function();
                }
            }
        }

        // Render function with timestamp
        function render(now) {
            requestAnimationFrame(render);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Set up modelview and projection matrices
            let modelview = Mat4.identity().mul(cam.get_view_matrix());
            let normalMatrix = Mat3.normalFromMat4(modelview);

            set_uniform_matrix4(gl, shader_program, "modelview", modelview.data);
            set_uniform_matrix4(gl, shader_program, "projection", projection.data);
            gl.uniformMatrix3fv(gl.getUniformLocation(shader_program, "normalMatrix"), false, normalMatrix.data);

            // Bind the material's texture and render the sphere
            gl.activeTexture(gl.TEXTURE0);
            metal.bind(gl);

            sphere.render(gl);
        }

        // Start rendering and updating
        requestAnimationFrame(render);
        setInterval(update, DESIRED_MSPT);
    </script>
</body>
</html>