-- CptS 355 - Spring 2023 -- Homework1 - Haskell
-- Name: Naomi Dion-Gokan
-- Collaborators: 
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
{-# HLINT ignore "Use camelCase" #-}

module HW1
     where

-- The top levels binding functions were generated by Visual Studio Code

-- P1(a) count ;  6%

{-Function named count that returns an Int and accepts a list and a value.
    The function  returns the number of occurrences of that value in the input list.-}

count :: (Num a, Eq t) => t -> [t] -> a  -- Top level-binding with type signature
count x_value [] = 0  -- when the list is empty, return 0
count x_value (x:xs) | x_value == x = count x_value xs + 1  -- For the case where the value we want corresponds to that x element of the list, increment the count by 1 
                     | otherwise = count x_value xs  -- In case, the value we want does not corresponds to that x element of the list, keep going through the list

-- P1(b) diff ;  6%

{-a function that takes two lists as input and returns the difference of the first list with respect 
to the second.  The input lists may have duplicate elements. If an element in the first list also appears in the 
second one, the element – and its duplicate copies – should be excluded in the output.  
The elements in the resulting list may have arbitrary order. -}

diff :: Eq t => [t]-> [t] ->[t]   -- Top level-binding with type signature

  -- Base cases for both lists
diff [] y2 = [] -- when the first list is empty, return an empty list         
diff y1 [] = y1 -- when the second list is empty, return the first list
 
diff (x:y1) y2 | count x y2 == 0 = x : diff y1 y2
               | otherwise = diff y1 y2
     

-- P1(c) bag_diff ; 8%
 {- A function diff that takes two lists as input and returns the difference of the first list with respect 
to the second.  The input lists may have duplicate elements. If an element appears in both lists and if the 
number of duplicate copies of the element is bigger in the first list, then this element should appear in the 
result as many times as the difference of the number of occurrences in the input lists.  
The duplicates should not be eliminated in the result.  The elements in the resulting list may have arbitrary 
order.-}

bag_diff :: Eq t => [t] -> [t] -> [t]  -- Top level-binding with type signature

     -- Base cases for both lists
bag_diff [] z2 = [] -- when the first list is empty, return an empty list         
bag_diff z1 [] = z1 -- when the second list is empty, return the first list

bag_diff (x:z1) z4 |  count x z4 == 0 = x : bag_diff z1 z4  --when count = 0, there is no common element
                   |  1 + count x z1  > count x z4   = x : bag_diff z1 z4 --when there is more occurence of the duplicate in the first list
                   | otherwise = bag_diff  z1 z4


-- P2  everyN ; 10%
{-The function everyN takes a list and a number ‘n’ (representing a count) and returns every nth value in 
the input list. -}


everyN :: (Num t, Ord t) => [a] -> t -> [a]   -- Top level-binding with type signature
everyN lst1 n = everyN_helper lst1 n n

      where
           everyN_helper [] a4 a5 = [] --base case, when the list is emty, return an empty list
           everyN_helper (x:xs) a4 0 = []  -- when n = 0, return an empty list
           everyN_helper (x:xs) a4 a5 | a5 < 0 = [] -- when n < 0 (negative), return an empty list
           everyN_helper (x:xs) a4 a5 | a4 == 1 = x : everyN_helper xs a5 a5 
                                      | otherwise = everyN_helper xs (a4 - 1) a5 

-- P3(a) make_sparse ; 15%
{- A function make_sparse which takes a compressed vector value (represented as a Haskell list of 
tuples)  and returns the equivalent sparse vector (including all 0 values). -}
-- Potential ideas of the equation of the function: make_sparse :: ([(m1,m2)]) ->[m3]

make_sparse []  = [] --when the list is empty, return an empty list  
--make_sparse m [] = make_sparse_helper m 0
make_sparse ( (x,y) : xs) = make_sparse_helper ( (x,y) : xs) 0
     where
       make_sparse_helper [] _ = [] --when the list is empty, return an empty list  
       make_sparse_helper ((x,y): xs) m7 | x == m7  = y : make_sparse_helper xs (m7 + 1)
                                         | otherwise = 0 :  make_sparse_helper ((x,y) : xs) (m7 + 1) -- moving forward in list
                                        
                                          
 

-- P3(b) compress ; 15%
{- a function compress which takes a sparse vector value (represented as a Haskell list)  and returns 
the equivalent compressed values as a list of tuples. -}

compress :: (Eq b, Num b, Num a) => [b] -> [(a, b)]  -- Top level-binding with type signature
compress [] = []  --when the list is empty, return an empty list  
compress (x:xs) = compress_helper (x:xs) 0

      where
       compress_helper [] m8 = [] --when the list is empty, return an empty list  
       compress_helper (x:xs) m8 | x == 0  = compress_helper xs (m8 + 1) -- moving forward in list
                                 | otherwise = (m8,x) : compress_helper xs (m8 + 1) -- x!= 0, moving forward in list
              
                              
-- P4 added_sums ; 8%
{- a function compress which takes a sparse vector value (represented as a Haskell list)  and returns 
the equivalent compressed values as a list of tuples. -}

added_sums :: Num a => [a] -> [a]  -- Top level-binding with type signature; Adding "Num a" solved the issue of instance of the helper function 
added_sums [] = [] -- base case, when the list is emty, return an empty list

added_sums b1 = added_sums_helper b1 0    -- Helper function

        where
added_sums_helper :: Num t => [t] -> t -> [t]
added_sums_helper [] b1 = [] -- base case, when the list is emty, return an empty list
added_sums_helper (x:xs) b1 = (x + b1) : added_sums_helper xs (x + b1) -- calculate the sum of the previous element and the current element and increment the sums as you keep going
   

-- P5 find_routes ; 8%
{- function find_routes that takes the list of bus routes and  a stop name, and returns the list of the 
bus routes which stop at the given bus stop. -}  

find_routes :: (Foldable t1, Eq t2) => t2 -> [(a, t1 t2)] -> [a]  -- Top level-binding with type signature

-- Base case  
find_routes _ [] = []  
find_routes c1 ( (bus_route, bus_stop):xs) | c1 `elem` bus_stop = bus_route : find_routes c1 xs 
                                           | otherwise = find_routes c1 xs


-- P6 group_sum ; 15% 
{- A function takes two arguments where the first argument is a list (lst) and the second 
argument is an integer (n). The goal is to produce a result in which the elements of the original list have 
been collected into ordered sub-lists each containing maximum number of consecutive elements from lst 
summing up to  or less than  n*2^k (where is k  the group number starting at 0 , i.e., k=0,1,2,3,4...).  
The leftover elements (if there are any) are included in the last sub-list with a sum less than n*2^k.   
When elements are added to the groups, if the next element in the input list (lst) is greater than n*2^k, 
the group will be empty list [].  -}

     -- That function has been fully implemented (It is not complete), but the test case yes
 

group_sum [] n = [] -- base case, when the list is emty, return an empty list
group_sum lst n = group_sum_helper lst n 0 0 []

   --  where
group_sum_helper sum [] n k [] = []  -- when the list is emty as well as the sublist, return an empty list
group_sum_helper sum [] n k d1  = reverse d1
--group_sum_helper sum (x:xs) n k d1 | (x + sum) > (n*2^k) = reverse d1 : group_sum_helper 0 (x:xs) n (k+1) []
                               --  | otherwise = group_sum_helper (sum + k) (x : d1) xs 

  

-- Assignment rules ; 3%
-- Your own tests; please add your tests to the HW1Tests.hs file ; 6%



